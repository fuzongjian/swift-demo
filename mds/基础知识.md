### 常见基础知识
1、View和Layer的区别。
- UIView负责交互，CALayer负责显示。
- iPhone是触摸屏，Mac是键盘操控。
- UIView继承于UIResponder，即可以响应事件；而CALayer继承于NSObject，所以不能响应事件。

2、imageNamed:与imageContentOfFile:的区别

| 类别 | 分析 |
| :-------------: | :------------- |
| `imageNamed: `      | 1、加载到内存当中，占据内存空间较大。</br> 2、相同的图片不会被重复加载。</br>3、会一直停留在内存中，不会随对象销毁而销毁，无法管理       |
| `imageContentOfFile` |1、加载到内存当中，占据内存空间较小。</br>2、相同的图片会重复加载到内存中。</br>3、加载到内存中的图片会随对象的销毁而销毁 |
| `总结` | 1、图片较小，且使用频繁，使用imageNamed:;</br>2、图片较大，且使用频率低，使用imageContentOfFile:。

3、分区情况
- 代码区：存放函数二进制代码
- 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量
- 堆区：malloc、new等操作动态申请
- 栈区：函数模块内申请，函数结束时有系统释放。存放局部变量、函数参数。

4、KVC底层实现`当对象调用setValue方法时，方法内部会做以下操作:`
- 检查是否存在对应key的set方法，如果存在，就直接调用set方法。
- 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量_key，如果有，则直接给成员变量赋值。
- 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。
- 如果没有找到，则调用valueForUndefinedKey: 和 setValue:forUndefinedKey,跑出异常，可根据需要进行重写。

5、内存对象
- `野指针`指针变量没有进行初始化或指向的空间已经被释放
- `僵尸对象`堆中已经释放的对象
- `空指针`孩子真赋值为空，nil

6、MRC、ARC使用什么机制来管理对象内存
- `MRC`通过引用计数器即retainCount的机制来决定对象是否需要释放。每次RunLoop完成一个循环的时候，都会检查对象的ratainCount，如果retainCount为0，说明该对象没有地方被使用，就被释放。
- `ARC`会在代码编译期自动在合适的位置插入release或autorelease，只要没有强指针指向对象，对象就会被释放。

7、调用对象的release方法会销毁对象吗？
- 不会，调用release只是将对象的引用计数器-1，当对象的引用计数器为0时会调用对象的dealloc方法才能释放对象的内存。
